# 程序员的观点

大多数关于系统（计算机架构、编译器、操作系统和网络）的书籍都是以读者将要设计和实现这样一个系统为前提编写的。我们称之为“构建者视角”。我们认为学生应该首先从系统如何影响程序的行为和性能的角度来学习系统，即“程序员视角”。

以下是一些简单的例子，展示了两种观点的对比：

### 计算机算术

逻辑设计和计算机架构课程描述了如何实现快速高效的算术电路。

对于程序员来说，真正重要的是用于表示整数和浮点数据的有限字长如何决定可以表示什么值以及不同操作的行为。

例如，考虑以下 C 函数来计算 5、50、500、5000、50000、500000 和 5000000 的平方：

无效显示正方形（）  

```c
void show_squares()
{
    int x;
    for (x = 5; x <= 5000000; x*=10)
	printf("x = %d x^2 = %d\n", x, x*x);
}
```

在大多数机器上编译时，该程序会产生以下值：

x = 5 x^2 = 25  
x = 50 x^2 = 2500  
x = 500 x^2 = 250000  
x = 5000 x^2 = 25000000  
x = 50000 x^2 = -1794967296  
x = 500000 x^2 = 891896832  
x = 5000000 x^2 = -1004630016

前四个值完全符合预期，但后三个值似乎相当奇怪。我们甚至看到数字的“平方”可以是负数！由于数据类型int在大多数机器上使用 32 位二进制补码表示，因此程序无法将值 $2.5 \times 10^9$ 表示为int。

在第 2 章中，我们介绍了大多数计算机上用于表示整数的二进制补码系统及其数学属性。我们还从程序员的角度介绍了 IEEE 浮点表示法。

### 储存器系统

计算机架构课程花费了大量时间来描述设计高性能内存系统的细节。他们讨论了诸如直写与回写、直接映射与集合关联、缓存大小、索引等选择。演示假设设计者无法控制运行的程序，因此唯一的选择是尝试使内存系统与一组基准程序的需求相匹配。

对于大多数人来说，情况恰恰相反。程序员无法控制机器的内存组织，但他们可以重写程序以大大提高性能。考虑以下两个函数来复制 2048 X 2048 整数数组：

```c
void copyij(long int src[2048][2048], long int dst[2048][2048])
{
  long int i,j;
  for (i = 0; i < 2048; i++)
    for (j = 0; j < 2048; j++)
      dst[i][j] = src[i][j];
}

void copyji(long int src[2048][2048], long int dst[2048][2048])
{
  long int i,j;
  for (j = 0; j < 2048; j++)
    for (i = 0; i < 2048; i++)
      dst[i][j] = src[i][j];
}
```

这些程序具有相同的行为。它们仅在循环嵌套的顺序上有所不同。在 2.0 GHz Intel Core i7 Haswell 处理器上运行时， copyij运行时间为 4.3 毫秒，而copyji 需要 81.8 毫秒 — 慢了 19 倍以上！由于内存访问的顺序，copyij可以更好地利用缓存内存系统。

![](https://csapp.cs.cmu.edu/3e/images/mountain3e-labeled.gif)

内存系统的性能可以通过上图所示的_内存山_来直观地看出，它根据数据访问模式表征了内存的读取速度。如图所示，函数copyij在内存系统的顶部附近运行，而函数copyji在底部运行。我们使用这座山作为本书的标志，因为它清楚地说明了我们的目标，即了解系统设计如何影响程序行为和性能。

在第 6 章中，我们描述了内存层次结构及其对程序性能的影响。我们描述了诸如分块之类的编程技术，这些技术大大增强了内存访问的局部性，即使在大型数据集上也能实现高性能。

### 操作系统

操作系统课程涵盖操作系统组件的设计——调度程序、内存管理器、文件系统等。不过，只有一小部分程序员会编写此类代码。另一方面，他们可以使用系统调用（如fork、、等）访问操作系统的许多功能。任何课程通常都不会涉及这一级别的编程。在第 8 章中，我们描述了进程管理，以及程序员如何利用 Unix 和 Linux 的进程控制功能 wait。 exec

### 其他主题

我们涵盖了广泛的系统主题，全部从程序员的角度出发。除了上面提到的内容外，还包括机器级编程、优化编译器、处理器架构、链接、性能测量、虚拟内存、I/O、网络编程和并发性。在查看要涵盖的主题及其呈现方式时，我们使用了过滤器“经验丰富的应用程序程序员如何使用这些材料？”

### 关键点

- 本书的内容对程序员有直接价值。学生发现它解释了他们已经遇到的许多神秘问题，帮助他们更有效地编写和调试代码，并且他们的程序更可靠、更高效。即使这是他们唯一学习的系统课程，他们也将比许多入门级程序员达到更高的能力水平。
- 本书的内容独一无二。其中许多内容在其他任何书籍中都没有介绍，以前的课程也没有讲过。相反，传统的系统介绍要求程序员自己弄清楚如何利用他们在以构建器为中心的课程中学习的系统特性来改进他们的程序。程序员必须费力地阅读令人困惑的 Unix 手册页或阅读高级系统编程书籍，才能使用 Unix 提供的简单过程控制功能。
- 本书为以构建者为中心的课程奠定了坚实的基础。我们认为，更高级的系统课程_应该_从构建者的角度介绍系统。通过首先从程序员的角度研究这些系统，学生将更好地了解这些系统的需求和约束。在卡内基梅隆大学，我们的计算机系统简介课程已成为 CS 和 ECE 课程的必修课，涵盖：操作系统、网络、编译器、计算机图形学、计算机架构和嵌入式系统设计。
