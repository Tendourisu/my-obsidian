---
title: lec16-缓存系统总结
tags:
  - cs61c
  - 缓存
categories: dairy
date: " 2025-02-14T01:31:38+08:00 "
modify: " 2025-02-14T01:31:38+08:00 "
dir: dairy
share: false
cdate: " 2025-02-14 "
mdate: " 2025-02-14 "
---
# 计算机体系结构：缓存系统总结

---

## 1. 缓存基础概念

### 处理器与DRAM的延迟差距
- **1980**：1条指令时间 ≈ 1次DRAM访问时间  
- **2020**：1000条指令时间 ≈ 1次DRAM访问时间  
- **影响**：DRAM访问延迟严重影响CPU性能，需通过缓存缓解。

### 内存层次结构
- **层次特点**：  
  - 靠近处理器的层级更小、更贵、更快。  
  - 包含最近使用的数据子集（时间局部性）和邻近地址数据（空间局部性）。  
- **典型层级**：  
  ```
  寄存器 → 缓存 → 主存 → 磁盘
  ```

### 局部性原理
- **时间局部性**：最近访问的数据可能再次被访问。  
- **空间局部性**：访问某地址后，邻近地址可能被访问。  
- **应用**：缓存以块（64B常见）为单位加载数据。

---

## 2. 缓存术语与指标
| 术语          | 定义                                                                 |
|---------------|----------------------------------------------------------------------|
| 缓存命中      | 目标数据在缓存中找到                                                 |
| 缓存未命中    | 目标数据不在缓存中，需从主存加载                                     |
| 命中率        | 命中次数 / 总访问次数                                                |
| 缺失惩罚      | 未命中时，从主存加载数据到缓存的额外时间                             |
| 有效位        | 标识缓存行是否有效（1=有效，0=无效）                                 |
| 脏位          | 标识缓存行是否被修改（写回策略中需同步到主存）                       |

---

## 3. 缓存行与块
- **块大小**：缓存加载的最小单位（如64B）。  
- **示例**：访问字节地址`19910`未命中时，加载整个块`19210-25510`。  
- **优势**：利用空间局部性，减少频繁访问邻近地址的缺失。

---

## 4. 缓存策略

### 写策略
| 策略         | 行为                                                                 |
|--------------|----------------------------------------------------------------------|
| 写直达       | 同时更新缓存和主存，实现简单但增加内存流量。                         |
| 写回         | 仅更新缓存并标记脏位，替换时写回主存，减少内存流量。                 |

### 写分配策略
| 策略         | 行为                                                                 |
|--------------|----------------------------------------------------------------------|
| 写分配       | 写未命中时加载块到缓存并更新。                                       |
| 非写分配     | 写未命中时直接更新主存，不加载块到缓存。                             |

---

## 5. 替换算法

### 近似LRU（时钟算法）
- **机制**：  
  1. 每行包含一个引用位（`Referenced Bit`）。  
  2. 未命中时，按顺序扫描行：  
     - 引用位=1 → 置0，继续扫描。  
     - 引用位=0 → 替换该行。  
- **示例（4行全相联缓存）**：  
  ```plaintext
  初始状态：所有行无效 → 加载新行到第一个无效行。
  缓存满时：按顺序扫描，替换第一个引用位为0的行。
  ```

### 其他策略
- **MRU**：替换最近使用的行（适合循环访问模式）。  
- **随机替换**：无需跟踪元数据，但命中率不稳定。

---

## 6. 缓存类型

### 全相联缓存
- **特点**：数据可存于任意缓存行，需复杂替换策略（如LRU）。  
- **地址分解**：  
  ```
  全地址 = Tag | Byte Offset
  #offset_bits = log2(块大小)
  #tag_bits = 地址总位数 - #offset_bits
  ```

### 直接映射缓存
- **特点**：数据只能存于固定索引位置，冲突率高。  
- **地址分解**：  
  ```
  全地址 = Tag | Index | Byte Offset
  #index_bits = log2(缓存行数)
  ```

### 组相联缓存
- **特点**：数据存于固定索引的组内（组内多行），平衡冲突与复杂度。  
- **地址分解**：  
  ```
  全地址 = Tag | Index | Byte Offset
  #index_bits = log2(组数)
  ```

---

## 7. 地址分解与硬件实现

### 示例：32位地址，4KB缓存，16B块
- **参数计算**：  
  ```plaintext
  #offset_bits = log2(16) = 4
  #lines = 4KB / 16B = 256 → #index_bits = log2(256) = 8
  #tag_bits = 32 - 8 - 4 = 20
  ```
- **地址格式**：  
  ```
  | 31-12 (20位Tag) | 11-4 (8位Index) | 3-0 (4位Offset) |
  ```

### 硬件结构
- **直接映射缓存硬件**：  
  ```plaintext
  输入地址 → 提取Index → 匹配Tag → 检查有效位 → 返回数据。
  ```

---

## 8. 缺失类型
| 类型         | 原因                                                                 |
|--------------|----------------------------------------------------------------------|
| 强制缺失     | 首次访问某块，必然缺失。                                             |
| 容量缺失     | 缓存容量不足，替换后重新加载旧块。                                   |
| 冲突缺失     | 多块竞争同一索引（直接映射/组相联中特有）。                          |

```