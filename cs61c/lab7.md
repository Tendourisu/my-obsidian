---
title: lab7
tags:
  - cs61c
categories: dairy
date: " 2025-01-30T15:52:07+08:00 "
modify: " 2025-01-30T15:52:07+08:00 "
dir: dairy
share: false
cdate: " 2025-01-30 "
mdate: " 2025-01-30 "
---

好的，这是根据您提供的 “lec07.pdf” 整理的 Markdown 格式笔记，重点突出，并使用了 `> [!important]` 的 callout 语法：

### CS 61C: 更多 RISC-V 指令和函数实现

- **寄存器 (Registers)**
    - 寄存器是 **32 位**
    - 寄存器可以存储**任何值** ，例如：
        - 数组的起始指针
        - 字符串的指针
        - 整数值
- **已学指令**
    - **算术运算**: `add`, `sub`, `addi`
    - **内存访问**: `lw`, `lb`, `sw`, `sb`
    - **逻辑运算**: `and`, `or`, `xor`, `sll`, `slli`, `sra`, `srai`
    - **条件分支**: `beq`, `bne`, `blt`, `bltu`, `bge`, `bgeu`

        >[!important] RISC-V 没有 `ble` 和 `bgt` 指令，但可以通过交换操作数转换为其他指令来实现。例如 `A > B` 等价于 `B < A`； `A <= B` 等价于 `B >= A`。

- **无条件分支**
    - `j label`：**无条件跳转**到 `label` 处的代码
- **`if-else` 语句的实现**
    - 使用条件分支指令（例如 `bne`）跳转到 `else` 代码块。
    - 使用无条件跳转指令 (`j`) 跳过 `else` 代码块。
- **循环的实现**
    - 使用条件分支指令（例如 `bge`）来判断循环是否应该继续。
    - 使用无条件跳转指令 (`j`) 跳回循环的开始。
- **程序计数器 (Program Counter, PC)**
    - PC 是一个寄存器，存储**当前正在执行的指令的内存地址**。
    - **RV32 指令是 32 位 (4 字节)**。
    - 处理器通过**将 PC 加 4 字节**来移动到下一条指令。

### 函数调用

- **`JAL` 指令**
    - `jal rd, Label`：**跳转到 `Label`，并将返回地址存储在 `rd` 寄存器中**。
        - `Label` 由汇编器转换为 20 位偏移量。
    - 通常使用 **`x1` (别名 `ra`) 寄存器**来保存返回地址。
- **返回地址寄存器**
    - 当跳转到函数时需要返回地址。
    - 当因循环或分支跳转时不需要返回地址。
    - 可以使用 `jal x0, L1` 来避免保存返回地址。
- **伪指令 (Pseudo Instructions)**
    - 程序员可使用，但**并非 ISA 中实现**的指令。
    - 由汇编器转换为真实的 RISC-V 指令。
    - 例如 `bgt x2 x3 foo` 会被转换为 `blt x3 x2 foo`。
    - `j L1` 等价于 `jal x0, L1`，不保存返回地址.
- **`JALR` 指令**
    - `jalr rd, rs, imm`：跳转到 `[rs] + imm`，并将返回地址存储在 `rd` 寄存器中。
    - `jalr x0, rs, 0` 等价于 `jr rs`。
    - `jalr x0, ra, 0` 等价于 `jr ra`，常用于函数返回，也等价于 `ret`。
- **函数调用时寄存器的保存**
    - 被调用的函数可能覆盖调用者正在使用的寄存器值。
    - 可以通过在函数调用前保存寄存器并在返回前恢复来避免这种情况。
    - 可以使用**栈 (Stack)**来保存这些值。

### 栈 (Stack)

- **栈指针 (Stack Pointer, SP)**
    - SP 寄存器 (x2) 存储栈顶的内存地址。
- **栈帧 (Stack Frame)**
- **栈操作**
    - **入栈 (PUSH)**: 将 SP **递减**，并在新栈顶存储值。使用`addi sp, sp, -x` 来调整栈指针，使用 `sw` 指令将数据压入栈。
    - **出栈 (POP)**: 将 SP **递增**，从栈顶取出值。使用 `addi sp, sp, x`来调整栈指针，使用 `lw` 指令将数据弹出栈。

### 调用约定 (Calling Convention)

- **调用者保存 (Caller-saved)**: 调用者负责保存的寄存器，包括临时寄存器 (`t0-t6`, `a0-a7`, `ra`)。
- **被调用者保存 (Callee-saved)**: 被调用者负责保存的寄存器，包括保存寄存器 (`s0-s11`, `sp`)。
- **参数和返回值寄存器**
    - `a0-a7` 寄存器用于传递函数参数。
    - `a0` 和 `a1` 也用作返回值寄存器。
- **函数调用示例**
    - 函数调用前，需要在栈上保存 `ra` 和被调用者保存的寄存器 (如 `s0`, `s1`等)。
    - 函数调用后，需要从栈中恢复 `ra` 和被调用者保存的寄存器。
    - 使用`addi sp, sp, -x` 指令调整栈指针，为局部变量分配空间。
    - 使用 `lw` 和 `sw` 指令在栈上存储和读取数据。
    - 使用 `jr ra` 返回到调用函数。
- **函数调用的六个基本步骤**
    1. 将参数放入函数可以访问的位置 (参数寄存器)。
    2. 将控制转移到函数 (使用跳转指令)。
    3. 获取函数所需的本地存储资源 (在栈上为局部变量分配空间)。
    4. 执行函数所需的任务。
    5. 将结果值放入调用代码可以访问的位置 (a0-a1 寄存器)。
    6. 将控制权返回到调用点 (ret)。
