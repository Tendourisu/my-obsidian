---
title: "2025-W03-01"
tags:
  - " #周记 "
categories: dairy
date: " 2025-01-13T10:56:39+08:00 "
modify: " 2025-01-13T10:56:39+08:00 "
dir: dairy
share: false
cdate: " 2025-01-13 "
mdate: " 2025-01-13 "
---

# 2025 -W 03 - 01

## Review

## Next Week Plan

## Time Line

## THOUGHTS

## LINKS

```dataviewjs
// Configuration for collecting LINKS sections from daily notes
const tars = {
  'LINKS': 2,  // Collect second-level LINKS headings
}

await dv.view('zob_config/js/show', {
  // Get only daily notes from dairy folder
  files: dv.pages('"dairy"')
    .where(p => {
      // Extract the week number from the current file name (weekly note)
      const weekMatch = dv.current().file.name.match(/(\d{4})-W(\d{1,2})/);
      if (!weekMatch) return false;

      const [_, weekYear, weekNum] = weekMatch;

      // Extract date components from daily note name (2024-49-12-08-7 format)
      const dateMatch = p.file.name.match(/(\d{4})-(\d{1,2})-(\d{2})-(\d{2})-(\d{1})/);
      if (!dateMatch) return false;

      const [__, year, week, month, day] = dateMatch;

      // Check if the daily note belongs to the same week and year
      return year === weekYear && week === weekNum;
    })
    .sort(p => {
      // Create sortable date string from daily note format
      const [_, year, week, month, day] = p.file.name.match(/^(\d{4})-(\d{1,2})-(\d{2})-(\d{2})-(\d{1})$/);
      // Sort by YYYYMMDD format (descending)
      return -1 * parseInt(`${year}${month.padStart(2, '0')}${day.padStart(2, '0')}`);
    }),

  kwd: false,      // Don't filter by keywords
  showHead: false, // Don't include heading in output
  tars,           // Target sections to collect (LINKS)
  obsidian,       // Pass obsidian object
  scale: 0.8,     // Scale of rendered content

  // List item configuration
  li: ([p, li]) => {
    const [_, year, week, month, day] = p.file.name.match(/^(\d{4})-(\d{1,2})-(\d{2})-(\d{2})-(\d{1})$/);
    const formattedDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
    // Create a header with date and file link, followed by the content
    return dv.paragraph(`### ${formattedDate} [[${p.file.path}|${p.file.name}]]\n${li}`);
  },
});
```

```dataview
table 
    dateformat(date, "ccc") as 星期, 
    L.text as LINKS, 
    L.outlinks as 链接
from "dairy/daily"
flatten file.lists as L
where 
    !L.parent and
    meta(L.section).subpath = "LINKS" and
    dateformat(date(file.outlinks), "yyyy-'W'WW") = dateformat(date(this.file.outlinks), "yyyy-'W'WW")

```

```dataview
table without id 
	file.link as 文件名, 
	file.folder as "文件夹", 
	file.mtime as 修改时间 
from "dairy/daily"
WHERE file.mtime >= date(today) - dur(7 day) 
sort file.mtime desc 
limit 20
```

```dataviewjs
const headers = ["文件名", "内容"];
// 目标小标题，支持正则匹配
const targetHeading = /^.{0,9}目标小标题（不含#）.{0,4}$/i;
// 按【路径或文件夹、文件名、标签】筛选并按修改时间降序排列
const pages = dv.pages('!"00数据管理"').filter(p => !p.file.path.includes("龥") && /^(?!.*(排除的关键词2|模板\-)).*/.test(p.file.name)).sort(p=>p.file.mtime,"desc");
const pagesArray = pages.array();
const targetPagesArray = [];
const contentArray = [];

for(let i = 0; i < pagesArray.length;i++) {
    const currentFile = pagesArray[i].file;
    const sectionCache = app.metadataCache.getFileCache(currentFile);

    const headingCache = sectionCache.headings?.filter(h => {
        return targetHeading.test(h.heading)
    })

    if(headingCache?.length > 0) {
        const headingRange = {
            start: headingCache[0].position.start.offset,
            end: headingCache[0].position.end.offset,
        };
        const heading = headingCache[0].heading;
        const content = await dv.io.load(currentFile.path);

        if(!content) continue;
        const headingInRange = content.slice(headingRange.start, headingRange.end);
        const contentInNextRange = content.slice(headingRange.end);

        const level = headingInRange.match(/#{1,6}/)[0].length;
        const nextHeadingRegex = new RegExp(`(^|\\n)#{1,${level}}\\s`);

        const position = contentInNextRange.match(nextHeadingRegex);

        let contentRange;
        let positionEnd;

        if(position) {
            positionEnd = headingRange.end + position?.index;
            contentRange = content.slice(headingRange.end, positionEnd);
        }else {
            contentRange = content.slice(headingRange.end);
        }
        const link = dv.sectionLink(currentFile.name, heading)
        contentArray.push({
            file: link,
            content: contentRange,
        })
    }
    //将结果限制在50条以内
    if (contentArray.length >= 50) {
        break;
    }
}
dv.table(headers, contentArray.map(
    p =>
        [
            p.file,
            p.content,
        ]
))
```

```dataviewjs
//输入目标小标题（含#），例如：#### 项目进度条
const header = '## LINKS'

// 按【路径或文件夹、文件名、标签】筛选并按修改时间降序排列
const pages = dv.pages('[[<% tp.file.title %>]]').filter(p => p.file.name.includes("") && p.file.path.includes("fn")).filter(p => p.file.name.includes("") || p.file.name.includes("")).sort(p=>p.编码,"asc");

// This regex will return text from the Summary header, until it reaches
// the next header, a horizontal line, or the end of the file
const regex = new RegExp(`\n${header}\r?\n(.*?)(\n#+ |\n---|$)`, 's')

for (const page of pages) {
    const file = app.vault.getAbstractFileByPath(page.file.path)
    // Read the file contents
    const contents = await app.vault.read(file)
    // Extract the summary via regex
    const summary = contents.match(regex)
    //显示全部包括空结果if (summary) {
    //不显示空结果if (summary && summary[1].trim()) {
    if (summary && summary[1].trim()) {
        // Output the header and summary
        dv.header(4, '[['+ file.basename + '|'+page.编码+' '+page.需求+']]')
        //或者dv.header(2, '[[' + file.basename + ']]')
        dv.paragraph(summary[1].trim())
    }
}
```

```dataviewjs
const headers = ["文件名", "内容"];

// 从当前周记文件名中获取年份和周数（格式如：2025-W3-01）
const weeklyPattern = /(\d{4})-W(\d+)/;
const match = dv.current().file.name.match(weeklyPattern);

if (!match) {
    dv.paragraph("周记文件名格式无效");
    return;
}

const year = match[1];     // 年份
const week = match[2];     // 周数

// 在日记文件夹中查找对应年周的文件
const pages = dv.pages('"diary/daily"')
    .filter(p => {
        // 从日记文件名中提取年份和周数部分（格式如：2025-03-01-19-7，其中19是周数）
        const parts = p.file.name.split('-');
        const fileYear = parts[0];
        const fileWeek = parts[1];  // 第四个部分是周数
        
        return fileYear === year && fileWeek === week;
    })
    .sort(p => p.file.name);

const contentArray = [];

// 提取每个文件中的LINKS部分
for (let i = 0; i < pages.length; i++) {
    const currentFile = pages[i].file;
    const sectionCache = app.metadataCache.getFileCache(currentFile);
    const linksHeading = sectionCache.headings?.find(h => h.heading === "LINKS" && h.level === 2);
    
    if (linksHeading) {
        const content = await dv.io.load(currentFile.path);
        if (!content) continue;
        
        const headingStart = linksHeading.position.end.offset;
        const nextHeading = sectionCache.headings?.find(h => 
            h.position.start.offset > headingStart
        );
        
        const contentEnd = nextHeading 
            ? nextHeading.position.start.offset 
            : content.length;
            
        const linksContent = content.slice(headingStart, contentEnd).trim();
        
        contentArray.push({
            file: dv.fileLink(currentFile.name),
            content: linksContent
        });
    }
}

dv.table(headers, contentArray.map(p => [p.file, p.content]));
```
