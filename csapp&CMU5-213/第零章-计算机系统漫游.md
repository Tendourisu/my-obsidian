---
title: " 2025-01-19 "
tags:
  - csapp
  - CMU5-213
  - OS
categories: dairy
date: " 2025-01-19T20:08:07+08:00 "
modify: " 2025-01-19T20:08:07+08:00 "
dir: dairy
share: false
cdate: " 2025-01-19 "
mdate: " 2025-01-19 "
---

# hello. c

- 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。
- 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。
- GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。过程如下图。
![image.png](https://raw.githubusercontent.com/Tendourisu/images/master/202501192024425.png)
- 执行这四个阶段的程序（**预处理器**、**编译器**、**汇编器**和**链接器**）一起构成了**编译系统**（compilation system）。

	- **预处理阶段。**预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的`#include <stdio.h>`命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。
	    
	- **编译阶段。编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序**。该程序包含函数 main 的定义，如下所示∶
	    

    ```Assembly
    main:
        subq $8, %rsp
        movl $.LC0, %edi
        call puts
        movl $0, %eax
        addq $8, %rsp
        ret
    ```
    
    定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。
    
	- **汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序**（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。
	    
	- **链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行。